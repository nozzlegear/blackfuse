// Source for much of this build script: SAFE-Stack https://github.com/SAFE-Stack/SAFE-BookStore/blob/65bb1b9049ee6b6c32c457e8ed1d876e6b96796d/build.fsx

#r @"packages/build/FAKE/tools/FakeLib.dll"
#r @"packages/build/DotEnvFile/lib/net452/DotEnvFile.dll"
// open Constants
// #load @"./constants.fsx"

open Fake
open System
open System.IO

module Option = 
    /// Option.defaultValue doesn't work on Linux? Use this as a polyfill.
    let withDefaultValue v o = match o with | Some x -> x | None -> v

let mutable dotnetExePath = "dotnet"
// let version = Constants.version
let deployDir = "./deploy" |> FullName
let clientDir = "./src/client" |> FullName
let serverDir = "./src/server" |> FullName

let resolve path = Path.Combine(__SOURCE_DIRECTORY__, path)

let run' timeout cmd args dir =
    if execProcess (fun info ->
        info.FileName <- cmd
        if not (String.IsNullOrWhiteSpace dir) then
            info.WorkingDirectory <- dir
        info.Arguments <- args
    ) timeout |> not then
        failwithf "Error while running '%s' with args: %s" cmd args

let run = run' System.TimeSpan.MaxValue

let runDotnet workingDir args =
    let result =
        ExecProcess (fun info ->
            info.FileName <- dotnetExePath
            info.WorkingDirectory <- workingDir
            info.Arguments <- args) TimeSpan.MaxValue
    if result <> 0 then failwithf "dotnet %s failed" args

let platformTool tool winTool =
    let tool = if isUnix then tool else winTool
    tool
    |> ProcessHelper.tryFindFileOnPath
    |> function Some t -> t | _ -> failwithf "%s not found" tool

let nodeTool = platformTool "node" "node.exe"
let npmTool = platformTool "npm" "npm.cmd"
let yarnTool = platformTool "yarn" "yarn.cmd"

do if not isWindows then
    // We have to set the FrameworkPathOverride so that dotnet sdk invocations know
    // where to look for full-framework base class libraries
    let mono = platformTool "mono" "mono"
    let frameworkPath = IO.Path.GetDirectoryName(mono) </> ".." </> "lib" </> "mono" </> "4.5"
    setEnvironVar "FrameworkPathOverride" frameworkPath

let toMap dict =
    dict :> seq<_>
    |> Seq.map (|KeyValue|)
    |> Map.ofSeq

let envFile =
    if File.Exists "./env.yml"
    then Some <| DotEnvFile.DotEnvFile.LoadFile "./env.yml"
    elif File.Exists "./env.dev.yml"
    then Some <| DotEnvFile.DotEnvFile.LoadFile "./env.dev.yml"
    else None
    |> Option.map toMap

let addProtocol (url: string) =
    let url = url.ToLower()

    if url.StartsWith "https://" || url.StartsWith "http://"
    then url
    else sprintf "http://%s" url

Target "Clean" (fun _ ->
    !!"src/**/bin"
    |> CleanDirs

    !! "src/**/obj/*.nuspec"
    ++ (clientDir </> "public/js/client.js")
    |> DeleteFiles

    CleanDirs ["bin"; "dist"; "temp"; deployDir]
)

Target "InstallDotNetCore" (fun _ ->
    dotnetExePath <- DotNetCli.InstallDotNetSDK "2.0.2"
)

// Target "SyncConstants" (fun _ ->
//     let banner = "/// THIS MODULE IS AUTO-GENERATED BY THE BUILD.FSX FILE, DO NOT MANUALLY EDIT IT OR CHECK IT INTO VERSION CONTROL" + Environment.NewLine
//     let tsFile = clientDir </> "constants.ts"
//     let fsFile = serverDir </> "Constants.fs"

//     File.WriteAllText(tsFile, banner + Constants.tsConstants)
//     File.WriteAllText(fsFile, banner + "module Constants" + Environment.NewLine + Constants.fsConstants)
// )

Target "Restore" (fun _ ->
    runDotnet __SOURCE_DIRECTORY__ "restore"
    run yarnTool "install --frozen-lockfile" __SOURCE_DIRECTORY__
)

Target "Build" (fun _ ->
    let dotnet = async { runDotnet __SOURCE_DIRECTORY__ "build" }
    let yarn = async { runDotnet (resolve "src/client") "fable yarn-run build" }

    [dotnet; yarn]
    |> Async.Parallel
    |> Async.RunSynchronously
    |> ignore
)

FinalTarget "KillProcess" (fun _ ->
    killProcess "dotnet"
    killProcess "dotnet.exe"
    killAllCreatedProcesses ()
)

Target "LoadEnvironment" (fun _ ->
    match envFile with
    | Some env ->
        printfn "Injecting environment from env file."

        Collections.Generic.Dictionary env
        |> DotEnvFile.DotEnvFile.InjectIntoEnvironment
    | None ->
        printfn "Found no environment file, using system environment."
)

Target "Run" (fun _ ->
    let ipAddress = "localhost"
    let port = 8000
    let fable = async { runDotnet clientDir "fable yarn-run watch" }
    let dotnet = async { runDotnet serverDir "run" }
    let openBrowser = async {
        System.Threading.Thread.Sleep(6000)

        envFile
        |> Option.bind (fun e -> e.TryFind "APP_DOMAIN")
        |> Option.map addProtocol
        |> Option.withDefaultValue (sprintf "http://%s:%d" ipAddress port)
        |> Diagnostics.Process.Start
        |> ignore
    }

    [dotnet; fable; openBrowser]
    |> Async.Parallel
    |> Async.RunSynchronously
    |> ignore
)

Target "All" DoNothing

"Clean"
    // ==> "SyncConstants"
    ==> "Restore"
    ==> "All"
    ==> "LoadEnvironment"
    ==> "Run"

"Clean"
    ==> "InstallDotNetCore"

"All"
    ==> "Build"

RunTargetOrDefault "All"