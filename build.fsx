// Source for much of this build script: SAFE-Stack https://github.com/SAFE-Stack/SAFE-BookStore/blob/65bb1b9049ee6b6c32c457e8ed1d876e6b96796d/build.fsx

#r @"packages/build/FAKE/tools/FakeLib.dll"
// open Constants
// #load @"./constants.fsx"

open Fake
open System
open System.IO
open System.Threading.Tasks

let mutable dotnetExePath = "dotnet"
// let version = Constants.version
let deployDir = "./deploy" |> FullName
let clientDir = "./src/client" |> FullName
let serverDir = "./src/server" |> FullName

let run' timeout cmd args dir =
    if execProcess (fun info ->
        info.FileName <- cmd
        if not (String.IsNullOrWhiteSpace dir) then
            info.WorkingDirectory <- dir
        info.Arguments <- args
    ) timeout |> not then
        failwithf "Error while running '%s' with args: %s" cmd args

let run = run' System.TimeSpan.MaxValue

let runDotnet workingDir args =
    let result =
        ExecProcess (fun info ->
            info.FileName <- dotnetExePath
            info.WorkingDirectory <- workingDir
            info.Arguments <- args) TimeSpan.MaxValue
    if result <> 0 then failwithf "dotnet %s failed" args

let platformTool tool winTool =
    let tool = if isUnix then tool else winTool
    tool
    |> ProcessHelper.tryFindFileOnPath
    |> function Some t -> t | _ -> failwithf "%s not found" tool

let nodeTool = platformTool "node" "node.exe"
let npmTool = platformTool "npm" "npm.cmd"
let yarnTool = platformTool "yarn" "yarn.cmd"

do if not isWindows then
    // We have to set the FrameworkPathOverride so that dotnet sdk invocations know
    // where to look for full-framework base class libraries
    let mono = platformTool "mono" "mono"
    let frameworkPath = IO.Path.GetDirectoryName(mono) </> ".." </> "lib" </> "mono" </> "4.5"
    setEnvironVar "FrameworkPathOverride" frameworkPath

Target "Clean" (fun _ ->
    !!"src/**/bin"
    |> CleanDirs

    !! "src/**/obj/*.nuspec"
    ++ (clientDir </> "public/js/client.js")
    |> DeleteFiles

    CleanDirs ["bin"; "dist"; "temp"; deployDir]
)

Target "InstallDotNetCore" (fun _ ->
    dotnetExePath <- DotNetCli.InstallDotNetSDK "2.0.2"
)

// Target "SyncConstants" (fun _ ->
//     let banner = "/// THIS MODULE IS AUTO-GENERATED BY THE BUILD.FSX FILE, DO NOT MANUALLY EDIT IT OR CHECK IT INTO VERSION CONTROL" + Environment.NewLine
//     let tsFile = clientDir </> "constants.ts"
//     let fsFile = serverDir </> "Constants.fs"

//     File.WriteAllText(tsFile, banner + Constants.tsConstants)
//     File.WriteAllText(fsFile, banner + "module Constants" + Environment.NewLine + Constants.fsConstants)
// )

Target "Restore" (fun _ ->
    runDotnet __SOURCE_DIRECTORY__ "restore"
    run yarnTool "install --frozen-lockfile" __SOURCE_DIRECTORY__
)

Target "Build" (fun _ ->
    let dotnet = async { runDotnet __SOURCE_DIRECTORY__ "build" }
    let yarn = async { run yarnTool "build" __SOURCE_DIRECTORY__ }

    [dotnet; yarn]
    |> Async.Parallel
    |> Async.RunSynchronously
    |> ignore
)

FinalTarget "KillProcess" (fun _ ->
    killProcess "dotnet"
    killProcess "dotnet.exe"
    killAllCreatedProcesses ()
)

Target "Run" (fun _ ->
    let ipAddress = "localhost"
    let port = 8000
    let fable = async { runDotnet clientDir "fable yarn-run watch" }
    let dotnet = async { runDotnet serverDir "run" }
    let openBrowser = async {
        System.Threading.Thread.Sleep(5000)
        Diagnostics.Process.Start("http://" + ipAddress + sprintf ":%d" port) |> ignore
    }

    [dotnet; fable; openBrowser]
    |> Async.Parallel
    |> Async.RunSynchronously
    |> ignore
)

Target "All" DoNothing

"Clean"
    ==> "InstallDotNetCore"
    // ==> "SyncConstants"
    ==> "Restore"
    ==> "All"
    ==> "Run"

"All"
    ==> "Build"

RunTargetOrDefault "All"